input {
  file {
    path => "/usr/share/logs/*_*_*_[0-9]*_[0-9]*_*.{[lL][oO][gG]}"

    sincedb_path => "/usr/share/logstash/data/sincedb"

    start_position => "beginning"

    codec => multiline {
      pattern => "^[\w\d]{4} [\w\d]{6} [\w\d]{6} \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}\s\w+\s+\S+\s(\s+|Caused by:)"
      negate => false
      what => "previous"
      auto_flush_interval => 2
      charset => "CP1252"
    }
  }
}

filter {
  # Extrai os campos provenientes do nome do log
  mutate {
    add_field => { "log.filename" => "%{[log][file][path]}" }
  }
  mutate {
    gsub => [ "log.filename", "^.*/", "" ]
  }
  if [log.filename] {
    grok {
      match => {
        "log.filename" =>
          "%{DATA:application_type}_%{DATA:user.name}_%{DATA:host.name}_%{YEAR}%{MONTHNUM}%{MONTHDAY}_%{INT:session.time_compact}_%{INT:session.id_file}\.%{WORD:extension}"
      }
      # Se o nome do ficheiro não bater com o padrão complexo, vamos adicionar um tag
      tag_on_failure => ["_filename_parse_failure"]
    }
  }

  # Extrai os campos do conteúdo do log
  grok {
    match => {
      "message" => "(?m)^%{WORD:log.session_id}\s+%{WORD:log.sequence}\s+%{WORD:log.thread_id}\s+%{DATA:log.timestamp_str}\s+%{LOGLEVEL:log.level}\s+%{NOTSPACE:log.logger}\s+%{GREEDYDATA:log.message_full}"
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  if [log.level] in ["SEVERE", "WARNING"] {
    grok {
      match => {
        "message" => [
          # Padrão 1: Apanha "java.lang.Throwable: A mensagem"
          "(?m)(?<error.type>[\w\.]+(?:Exception|Error|Throwable)): %{GREEDYDATA:error.message_only}",

          # Padrão 2: Apanha "Caused by: java.lang.Throwable ..."
          "(?m)Caused by: (?<error.type>[\w\.]+(?:Exception|Error|Throwable))(: %{GREEDYDATA:error.message_only})?",

          # Padrão 3: Apanha "java.lang.Throwable" (sozinha na linha)
          "(?m)^(?<error.type>[\w\.]+(?:Exception|Error|Throwable))\s*$"
        ]
      }
      tag_on_failure => [] # Não falha se for um WARNING normal
    }
  }

  # Converte a string de timestamp para o campo @timestamp
  if [log.timestamp_str] {
    date {
      match => [ "log.timestamp_str", "YYYY-MM-dd HH:mm:ss,SSS" ]
      target => "@timestamp"
    }
  }

  # Substitui o campo message pelo conteúdo completo do log.message_full
  if [log.message_full] {
     mutate {
       strip => ["log.message_full"]
       replace => { "message" => "%{log.message_full}" }
     }
  }

  # Limpa campos desnecessários
  mutate {
    gsub => [ "message", "^[\w\d]{4} [\w\d]{6} [\w\d]{6} \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3} \w+\s+\S+ ", "" ]
    remove_field => [ "log.message_full", "log.timestamp_str", "log.filename", "extension", "error.message_only" ]
  }
}

output {
  kafka {
    bootstrap_servers => "kafka:9092"
    topic_id => "logs_java_siger"
    codec => json
  }

  stdout {
    codec => rubydebug
  }
}