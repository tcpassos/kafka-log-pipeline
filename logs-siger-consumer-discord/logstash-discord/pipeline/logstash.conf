input {
  kafka {
    bootstrap_servers => "${KAFKA_BOOTSTRAP}"
    topics => ["logs_java_sigercrashreport"]
    group_id => "logstash-discord-consumer"
    codec => json {
      charset => "CP1252"
    }
    consumer_threads => 1
    # Come√ßa a ler do final do t√≥pico (apenas mensagens novas)
    auto_offset_reset => "latest"
  }
}

filter {
  # Extrai os campos do conte√∫do do log
  grok {
    match => {
      "message" => "(?m)^%{WORD:log.session_id}\s+%{WORD:log.sequence}\s+%{WORD:log.thread_id}\s+%{DATA:log.timestamp_str}\s+%{LOGLEVEL:log.level}\s+%{NOTSPACE:log.logger}\s+%{GREEDYDATA:log.message_full}"
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  # Apenas processa logs com level SEVERE
  if [log.level] != "SEVERE" {
    drop { }
  }

  # Extrai informa√ß√µes de erro/exce√ß√£o
  grok {
    match => {
      "message" => [
        # Padr√£o 1: Apanha "java.lang.Throwable: A mensagem"
        "(?m)(?<error.type>[\w\.]+(?:Exception|Error|Throwable)): %{GREEDYDATA:error.message}",
        
        # Padr√£o 2: Apanha "Caused by: java.lang.Throwable ..."
        "(?m)Caused by: (?<error.type>[\w\.]+(?:Exception|Error|Throwable))(: %{GREEDYDATA:error.message})?",
        
        # Padr√£o 3: Apanha "java.lang.Throwable" (sozinha na linha)
        "(?m)^(?<error.type>[\w\.]+(?:Exception|Error|Throwable))\s*$"
      ]
    }
    tag_on_failure => []
  }

  # Converte a string de timestamp para o campo @timestamp
  if [log.timestamp_str] {
    date {
      match => [ "log.timestamp_str", "YYYY-MM-dd HH:mm:ss,SSS" ]
      target => "@timestamp"
      timezone => "America/Sao_Paulo"
    }
  }

  # Extrai informa√ß√µes do cliente (se dispon√≠vel nos fields)
  if [fields][client_id] {
    mutate {
      add_field => { "client_id" => "%{[fields][client_id]}" }
    }
  }

  # Constr√≥i mensagem formatada para Discord usando Ruby (para quebras de linha reais)
  ruby {
    code => '
      msg = "üö® **ALERTA: Log SEVERE no SigerCrashReport**"
      
      client_id = event.get("client_id")
      msg += "\n**Cliente:** #{client_id}" if client_id
      
      timestamp = event.get("log.timestamp_str")
      msg += "\n**Timestamp:** #{timestamp}" if timestamp
      
      logger = event.get("log.logger")
      msg += "\n**Logger:** #{logger}" if logger
      
      error_type = event.get("error.type")
      msg += "\n**Tipo de Erro:** #{error_type}" if error_type
      
      error_message = event.get("error.message")
      msg += "\n**Mensagem:** #{error_message}" if error_message
      
      # Processa o log completo
      full_msg = event.get("log.message_full")
      if full_msg
        # Garante que quebras de linha sejam preservadas
        full_msg = full_msg.gsub("\\n", "\n") if full_msg.include?("\\n")
        
        # Remove o prefixo (SSID SEQNUM THREAD TIMESTAMP LEVEL LOGGER) das linhas subsequentes
        full_msg = full_msg.gsub(/\n[a-zA-Z0-9]{4} [a-zA-Z0-9]{6} [a-zA-Z0-9]{6} \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}\s+\w+\s+\S+\s+/, "\n")
        
        if full_msg.length > 1500
          preview = full_msg[0..1500] + "..."
        else
          preview = full_msg
        end
        
        msg += "\n\n**Log Completo:**\n```\n#{preview}\n```"
      end
      
      event.set("discord_message", msg)
    '
  }
}

output {
  # Envia para Discord via webhook
  http {
    url => "${DISCORD_WEBHOOK_URL}"
    http_method => "post"
    format => "json"
    content_type => "application/json"
    mapping => {
      "content" => "%{discord_message}"
      "username" => "SIGER Alert Bot"
      "avatar_url" => "https://cdn-icons-png.flaticon.com/512/2569/2569194.png"
    }
  }

  # Log para debug (opcional - pode comentar em produ√ß√£o)
  stdout {
    codec => rubydebug
  }
}
