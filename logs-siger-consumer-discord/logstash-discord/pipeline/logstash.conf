input {
  kafka {
    bootstrap_servers => "${KAFKA_BOOTSTRAP}"
    topics => ["logs_java_sigercrashreport"]
    group_id => "logstash-discord-consumer"
    codec => json
    consumer_threads => 1
  }
}

filter {
  # Extrai os campos do conte√∫do do log
  grok {
    match => {
      "message" => "(?m)^%{WORD:log.session_id}\s+%{WORD:log.sequence}\s+%{WORD:log.thread_id}\s+%{DATA:log.timestamp_str}\s+%{LOGLEVEL:log.level}\s+%{NOTSPACE:log.logger}\s+%{GREEDYDATA:log.message_full}"
    }
    tag_on_failure => ["_grokparsefailure"]
  }

  # Apenas processa logs com level SEVERE
  if [log.level] != "SEVERE" {
    drop { }
  }

  # Extrai informa√ß√µes de erro/exce√ß√£o
  grok {
    match => {
      "message" => [
        # Padr√£o 1: Apanha "java.lang.Throwable: A mensagem"
        "(?m)(?<error.type>[\w\.]+(?:Exception|Error|Throwable)): %{GREEDYDATA:error.message}",
        
        # Padr√£o 2: Apanha "Caused by: java.lang.Throwable ..."
        "(?m)Caused by: (?<error.type>[\w\.]+(?:Exception|Error|Throwable))(: %{GREEDYDATA:error.message})?",
        
        # Padr√£o 3: Apanha "java.lang.Throwable" (sozinha na linha)
        "(?m)^(?<error.type>[\w\.]+(?:Exception|Error|Throwable))\s*$"
      ]
    }
    tag_on_failure => []
  }

  # Converte a string de timestamp para o campo @timestamp
  if [log.timestamp_str] {
    date {
      match => [ "log.timestamp_str", "YYYY-MM-dd HH:mm:ss,SSS" ]
      target => "@timestamp"
      timezone => "America/Sao_Paulo"
    }
  }

  # Extrai informa√ß√µes do cliente (se dispon√≠vel nos fields)
  if [fields][client_id] {
    mutate {
      add_field => { "client_id" => "%{[fields][client_id]}" }
    }
  }

  # Prepara mensagem formatada para Discord
  mutate {
    add_field => {
      "discord_message" => "üö® **ALERTA: Log SEVERE no SigerCrashReport**\n\n"
    }
  }

  if [client_id] {
    mutate {
      update => {
        "discord_message" => "%{discord_message}**Cliente:** %{client_id}\n"
      }
    }
  }

  if [log.timestamp_str] {
    mutate {
      update => {
        "discord_message" => "%{discord_message}**Timestamp:** %{log.timestamp_str}\n"
      }
    }
  }

  if [log.logger] {
    mutate {
      update => {
        "discord_message" => "%{discord_message}**Logger:** %{log.logger}\n"
      }
    }
  }

  if [error.type] {
    mutate {
      update => {
        "discord_message" => "%{discord_message}**Tipo de Erro:** %{error.type}\n"
      }
    }
  }

  if [error.message] {
    mutate {
      update => {
        "discord_message" => "%{discord_message}**Mensagem:** %{error.message}\n"
      }
    }
  }

  if [log.message_full] {
    # Limita o tamanho da mensagem para n√£o exceder limites do Discord
    ruby {
      code => '
        full_msg = event.get("log.message_full")
        if full_msg && full_msg.length > 500
          event.set("log.message_preview", full_msg[0..500] + "...")
        else
          event.set("log.message_preview", full_msg)
        end
      '
    }
    
    mutate {
      update => {
        "discord_message" => "%{discord_message}\n**Log Completo:**\n```\n%{log.message_preview}\n```"
      }
    }
  }
}

output {
  # Envia para Discord via webhook
  http {
    url => "${DISCORD_WEBHOOK_URL}"
    http_method => "post"
    format => "json"
    content_type => "application/json"
    mapping => {
      "content" => "%{discord_message}"
      "username" => "SIGER Alert Bot"
      "avatar_url" => "https://cdn-icons-png.flaticon.com/512/2569/2569194.png"
    }
  }

  # Log para debug (opcional - pode comentar em produ√ß√£o)
  stdout {
    codec => rubydebug
  }
}
